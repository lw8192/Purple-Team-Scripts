# Binary Exploitation    
## Learn     
[Flagbot CTF Lessons](https://flagbot.ch/material/)     
[Live Overflow Paylist](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)   
[Binary Exploitation Notes](https://ir0nstone.gitbook.io/notes/)    

## Tools     
[GDB](https://www.sourceware.org/gdb/)    
[GEF](https://github.com/hugsy/gef)   
[Cutter](https://cutter.re/)    
[PEDA](https://github.com/longld/peda)    
[Pwntools](https://github.com/Gallopsled/pwntools)     
Ghidra    
[Online x86 / x64 Assembler and Disassembler](https://defuse.ca/online-x86-assembler.htm#disassembly2)  

        file binary     #note architechure of the binary, are debugging symbols stripped?     
        strings binary   #note strings, function calls   
If a binary is not stripped of debugging symbols:    

        readelf -s program     
Disassemble and find function locations:       

        objdump -d program     
Open the binary in Ghidra, decompile it and look at the source code.   
ltrace: record library calls made in an executable to see what context they are used in.      

        ltrace ./program      

## Format String Vulnerabilities     
Format parameter: Escape sequences - begins with a %, uses a single char shorthand. Common format parameters: %d, %u, %x, %p.            
Is user input passed to printf, scanf or similiar functions in a way you can control?    

        printf(variable);   //c code vulnerability   
        %x%x   #test as user input   
        %p %p    #print out pointer values - test to see if you can disclose vital info (like a flag)  
But what if the string contains a format parameter?? The format function should eval and try to access the function arg by adding to the frame pointer - if arg isn't there adding to the frame pointer will reference a piece of memory in a preceding stack frame.       
Further notes: https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b             
        
## GEF    
[GEF Documentation](https://hugsy.github.io/gef/)    
Extend the features of GDB.    
Check security protections on a binary:     

    checksec filename  
    checksec     #if gdb is already attached to a process    

    pattern create 200    #create a pattern   
    pattern offset waab   #get the offset 

## Memory Protections   
NX: Nonexecutable Stack, Linux. Defines memory regions as instructions or data - your input gets stored as data and can't be executed. ret2libc - NX bypass.             
DEP: Data Execution Prevention, Windows version of NX, the CPU will not execute code in the heap or stack.       
Stack Canary:      
ASLR:  address space layer randomization. Instead of preventing execution on the stack - randomize the stack memory layout. Attacker won't know where the waiting shellcode is to return execution into it.          
Switch off ASLR:      

                echo 0 > /proc/sys/kernel/randomize_va_space    
PIE - Position Independent Executables (PIE), protects against ROP attacks. The binary and it's dependancies are loaded into random locations in virtual memory each time the program is executed.       
SafeSEh:      
Relocation Read-Only (RELRO)      

## Structured Exception Handlers (SEH)    
Used to bypass stack cookies and SafeSEH.       

## Return Oriented Programming (ROP)       
[Ropper tool](https://scoding.de/ropper/)     
[ROPGadget](https://github.com/JonathanSalwan/ROPgadget)     
Allows you to bypass NX on Linux systems, avoid DEP on Windows systems          
Common defense against ROP techniques: ASLR         
https://bordplate.no/blog/en/post/what-is-rop/    
https://bordplate.no/blog/en/post/interactive-rop-tutorial/    
[Return Oriented Shellcode](https://www.youtube.com/watch?v=7BMyVvYv5d0)    
Chain together small snippets of useful assembly code in the binary (or others loaded by it) - the goal is usually to call system("/bin/sh")      
x64 Linux example: set the registers %rdi = address of string "/bin/sh" , %rsi = 0, %rdx = 0, then jump to the address of system      
CTF ex: find the location of 'cat flag.txt' and pass it to system() to execute it and return the output.          

### ret2libc (Return to libc)     
[Return to Libc Explained](https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf)    
[Bypassing non-executable-stack during exploitation using return-to-libc](https://css.csail.mit.edu/6.858/2019/readings/return-to-libc.pdf)    
Exploit buffer overflows on systems where stack memory is protected with NX. For *nix systems.        
An attacker can't execute shellcode from the stack. ret2libc: bypass NX and use existing code from the standard C library shared object (/lib/i386-linux-gnu/libc-\*.so) that is loaded and mapped into the program's virtual address space. This is similiar to a standard stack buffer overflow, except the return address will point to the function system(const char *command) from the libc library. The program will be forced to jump to system() and execute injected shellcode as the command.                
payload = overflow + &system() + &exit() + &commmand       

        (gdb) p system  #find the memory address of system() from libc in the program's virtual memory    
        (gdb) p exit    #find the memory address of exit() 

### Sigreturn-oriented programming (SROP)     


